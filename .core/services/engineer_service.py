"""
Engineer Service for Studio Mode
================================
Autonomously generates code based on specifications using the 'C.O.R.E. Engineer' persona.
Implements the 'Refinist' approach: Functional Core first, then hardening.
"""

import os
import json
import httpx
from typing import List, Optional, Dict, Any
from pydantic import BaseModel
import litellm
import asyncio

from .lib.governor import governed, ActionType, get_governor

# --- CONFIGURATION ---
MEMORY_SERVER_URL = os.getenv("MEMORY_SERVER_URL", "http://127.0.0.1:8000")
DEFAULT_MODEL = os.getenv("LLM_MODEL", "gpt-4o-mini")
WORKSPACE_DIR = os.path.abspath("./workspace")

# --- PERSONA DEFINITION ---
ENGINEER_SYSTEM_PROMPT = """You are the C.O.R.E. Engineer, a specialized code generation agent.
Your primary objective is implementation, debugging, and optimization.
Follow the "Refinist" approach: Functional Core (v0.1) first, then hardening.
You must act as a Senior Software Architect.

Operational Constraints:
1. Safety Level: 2 (Standard Governor Compliance).
2. Tooling Isomorphism: Use standard tools (pwsh, git, npm).
3. Documentation: Write "Why-comments" explaining design choices.

Output Format:
Return ONLY the code block(s) requested. If explanation is needed, use comments within the code.
Do not wrap in markdown code blocks unless requested.
"""

class CodeGenerationRequest(BaseModel):
    task_id: str
    task_text: str
    context: str = ""
    file_path: Optional[str] = None  # If modifying existing file
    existing_content: Optional[str] = None # Content of file if modifying

class CodeGenerationResponse(BaseModel):
    task_id: str
    code: str
    explanation: str

class EngineerService:
    def __init__(self):
        self.client = httpx.AsyncClient(timeout=60.0)
        self.governor = get_governor()

    @governed(ActionType.LLM_CALL, lambda args: args[0])
    async def generate_code(self, req: CodeGenerationRequest) -> CodeGenerationResponse:
        """
        Generate code based on the request.
        """
        
        # Construct the prompt
        user_prompt = f"Task: {req.task_text}\n\n"
        
        if req.context:
            user_prompt += f"Context:\n{req.context}\n\n"
            
        if req.existing_content:
            user_prompt += f"Existing Content ({req.file_path}):\n```\n{req.existing_content}\n```\n\n"
            user_prompt += "Instructions: Modify the existing code to fulfill the task. Maintain existing style.\n"
        else:
            user_prompt += "Instructions: Generate new code to fulfill the task.\n"

        if req.file_path:
            user_prompt += f"Target File: {req.file_path}\n"

        # Call LLM
        try:
            response = await litellm.acompletion(
                model=DEFAULT_MODEL,
                messages=[
                    {"role": "system", "content": ENGINEER_SYSTEM_PROMPT},
                    {"role": "user", "content": user_prompt}
                ]
            )
            
            content = response.choices[0].message.content
            
            # Basic parsing if LLM wraps in markdown
            code = self._extract_code(content)
            
            return CodeGenerationResponse(
                task_id=req.task_id,
                code=code,
                explanation="Generated by C.O.R.E. Engineer"
            )

        except Exception as e:
            print(f"[Engineer] Generation failed: {e}")
            raise e

    def _extract_code(self, content: str) -> str:
        """Extract code from markdown code blocks if present."""
        if "```" in content:
            # simple extraction of first block
            try:
                start = content.find("```")
                # skip language identifier line
                end_first_line = content.find("\n", start)
                end = content.find("```", end_first_line)
                if end != -1:
                    return content[end_first_line+1:end].strip()
            except:
                pass
        return content

# --- FASTAPI APP ---
from fastapi import FastAPI, HTTPException

app = FastAPI(title="Engineer Service", version="1.0.0")
service = EngineerService()

@app.post("/engineer/generate")
async def generate_endpoint(req: CodeGenerationRequest):
    try:
        return await service.generate_code(req)
    except PermissionError as e:
        raise HTTPException(status_code=403, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/health")
def health():
    return {"status": "online", "persona": "C.O.R.E. Engineer"}

# --- CLI FOR TESTING ---
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8001)
